# Plan: Implementing Persistent, Branching Conversations with a History Dialog

This document outlines the plan to upgrade the existing chat application to support a persistent, tree-based conversation model with a `shadcn-vue` dialog for browsing chat history and in-line controls for navigating between conversation branches.

### Goal

To create a system where:
1.  Chat conversations, including AI tool usage, are saved to a database with branching support.
2.  The initial URL of a chat is recorded.
3.  A user can browse their chat history in a dialog.
4.  Chat titles are automatically generated by a lightweight AI model.
5.  From the dialog, a user can load a past chat or navigate to its original page.
6.  Users can navigate between different conversation branches using a pagination-style control (`< 1/3 >`) directly in the chat view.

---

## 1. Step 1: Database Schema

The Prisma schema will be updated to explicitly handle messages that contain multiple parts, such as text and tool calls.

```prisma
// In your prisma/schema.prisma

model Chat {
  id        String    @id @default(cuid())
  title     String?
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  messages  Message[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  sourceUrl String?
}

model Message {
  id         String    @id @default(cuid())
  chatId     String
  chat       Chat      @relation(fields: [chatId], references: [id])
  parentId   String?
  parent     Message?  @relation("MessageChildren", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children   Message[] @relation("MessageChildren")
  role       String    // 'user' or 'assistant'
  
  // We will store the parts array as a JSON string.
  // This is the most flexible way to store text, tool calls, and tool results.
  content    Json
  
  createdAt  DateTime  @default(now())
}
```**Key Change:** The `content` field is now of type `Json`. This allows us to store the entire `UIMessage.parts` array directly, which can contain text, tool calls, and tool results, without losing any structure.

---

## 2. Step 2: Backend API Endpoints & Logic

The backend logic remains largely the same, but it will now expect the `content` to be a JSON array when reading from and writing to the database.

- **`server/api/chat/[id].get.ts`**: The `buildTree` utility will now work with the `content` field as a JSON object.
- **`server/api/chat.post.ts`**: When saving messages in the `onFinish` callback, it will save the full `message.parts` array into the `content` field.

---

## 3. Step 3 & 4: Frontend Components

- **`ChatPane.vue` & `Message.vue`**: These components already work with the `message.parts` array, so no significant changes are needed here. They will seamlessly render text parts, tool call parts, and tool result parts as they did before.

This updated schema provides a robust and flexible way to store complex messages, including those with tool interactions, ensuring no data is lost.